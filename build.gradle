buildscript {
    ext.kotlin_version = '1.6.21'
    ext.dokka_version = '1.4.32'

    /**
     * Properties and environment variables needed to publish.
     */
    ext.jfrogUsername = (project.hasProperty('jfrog.username') ?
            project.property("jfrog.username") : '')
    ext.jfrogPassword = (project.hasProperty('jfrog.password') ?
            project.property("jfrog.password") : '')
    ext["signing.keyId"] = (project.hasProperty('signing.keyId') ?
            project.property("signing.keyId") : '')
    ext["signing.password"] = (project.hasProperty('signing.password') ?
            project.property("signing.password") : '')
    ext["signing.secretKeyRingFile"] = (project.hasProperty('signing.secretKeyRingFile') ?
            project.property("signing.secretKeyRingFile") : '')
    ext["mavenCentralUsername"] = (project.hasProperty('mavenCentralUsername') ?
            project.property("mavenCentralUsername") : '')
    ext["mavenCentralPassword"] = (project.hasProperty('mavenCentralPassword') ?
            project.property("mavenCentralPassword") : '')
    ext["sonatypeStagingProfileId"] = (project.hasProperty('sonatypeStagingProfileId') ?
            project.property("sonatypeStagingProfileId") : '')

    ext.getPropertyValue =  { propertyKey ->
        def property  = System.getenv(propertyKey)

        if (property == null) {
            logger.log(LogLevel.INFO, "Could not locate $propertyKey as environment variable. " +
                    "Trying local.properties")
            Properties properties = new Properties()
            if (project.rootProject.file('local.properties').exists()) {
                properties.load(project.rootProject.file('local.properties').newDataInputStream())
                property = properties.getProperty(propertyKey)
            }
        }

        if (property == null) {
            logger.log(LogLevel.WARN, "$propertyKey unavailable.")
        }

        return property
    }

    ext.getShortCommitSha = {
        def gitSha = System.getenv("CIRCLE_SHA1")

        if(gitSha != null) return gitSha.substring(0, 7) else return ""
    }

    ext.isPreRelease = (project.hasProperty("preRelease") && project.property("preRelease").toBoolean() == true)
    ext.audioSwitchVersion = "${versionMajor}.${versionMinor}.${versionPatch}" +
            (isPreRelease ? "-SNAPSHOT" : '')

    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.12.1'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath "org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version"
    }
}

plugins {
    id "com.diffplug.spotless" version '7.2.1'
    id "org.jetbrains.dokka" version "$dokka_version"
    id "io.github.gradle-nexus.publish-plugin" version '2.0.0'
    id "maven-publish"
    id "org.ajoberstar.grgit" version "5.3.2"
}
apply plugin: "com.diffplug.spotless"
spotless {
    format 'misc', {
        target '**/*.gradle', '**/*.md', '**/.gitignore'
        targetExclude 'docs/**'

        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()
    }
    java {
        target '**/*.java'
        googleJavaFormat().aosp()
    }
    kotlin {
        target '**/*.kt'
        ktlint()
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

nexusPublishing {
    repositories {
        sonatype {
            username = mavenCentralUsername
            password = mavenCentralPassword
            nexusUrl = uri("https://ossrh-staging-api.central.sonatype.com/service/local/")
            stagingProfileId = sonatypeStagingProfileId
        }
    }
}

/*
 * Utility GradleBuild task that enables defining custom tasks derived from gradle modules in a
 * root level gradle file.
 *
 * TODO: Replace this approach in favor of pushing tasks down into their respective modules.
 */
class RootGradleBuild extends GradleBuild {
    private static final String ROOT_PROJECT_NAME = "audioswitch-root"

    RootGradleBuild() {
        super()
        buildName = ROOT_PROJECT_NAME
    }
}

/*
 * Checks if release tag matches version and current commit
 */
def matchesVersion(versionTag) {
    def properties = new Properties()
    file("${rootDir}/gradle.properties").withInputStream { properties.load(it) }
    def releaseTag = "${properties.getProperty("versionMajor")}." +
            "${properties.getProperty("versionMinor")}." +
            "${properties.getProperty("versionPatch")}"

    return releaseTag == versionTag
}

tasks.register('validateReleaseTag', Exec) {
    description = 'Validate the release tag matches the release version present on commit'
    group = 'Git'
    doFirst {
        def circleTag = System.getenv("CIRCLE_TAG")
        def tagsMatch = matchesVersion(circleTag) ? ("true") : ("false")
        commandLine tagsMatch
    }
    workingDir "${rootDir}"
}

tasks.register('incrementVersion', RootGradleBuild) {
    description = 'Increment the SDK version after a release'
    group = 'Git'

    doLast {
        def gitBranch = grgit.repository.jgit.repository
                .exactRef('refs/remotes/origin/HEAD')
                ?.getTarget()
                ?.getName()
                ?.replace('refs/remotes/origin/', '')
        def circleTag = System.getenv("CIRCLE_TAG")
        def githubToken = System.getenv("GITHUB_TOKEN")
        def repoSlug = "${System.env.CIRCLE_PROJECT_USERNAME}/${System.env.CIRCLE_PROJECT_REPONAME}"
        def gitRef = "https://${githubToken}@github.com/${repoSlug}.git"
        def nextVersionPatch = versionPatch.toInteger() + 1
        def remoteName = "upstream"

        // Add remote if it doesn't exist
        try {
            grgit.remote.add(name: remoteName, url: gitRef)
        } catch (Exception ignored) {
            // Remote already exists
        }

        grgit.checkout(branch: gitBranch)

        if (true || matchesVersion(circleTag)) {
            println "Incrementing from versionPatch ${versionPatch} to ${nextVersionPatch}"

            // Update gradle.properties
            def gradlePropertiesFile = file('gradle.properties')
            def properties = new Properties()
            gradlePropertiesFile.withInputStream { properties.load(it) }
            properties.setProperty("versionPatch", nextVersionPatch.toString())
            gradlePropertiesFile.withOutputStream { properties.store(it, null) }

            // commit the change
            grgit.add(patterns: ['gradle.properties'])
            grgit.commit(message: "Bump patch version [skip ci]")
            grgit.push(remote: remoteName, refsOrSpecs: [gitBranch])
        }
    }
}

tasks.register('sonatypeAudioSwitchReleaseUpload', RootGradleBuild) {
    description = 'Publish an AudioSwitch release or pre-release'
    group = 'Publishing'
    dependsOn validateReleaseTag
    buildFile = file('build.gradle')
    tasks = ['assembleRelease', 'publishAudioSwitchReleasePublicationToSonatypeRepository', 'closeAndReleaseSonatypeStagingRepository']
    startParameter.projectProperties += gradle.startParameter.projectProperties + [
            'signing.keyId'            : "${getPropertyValue("SIGNING_KEY_ID")}",
            'signing.password'         : "${getPropertyValue("SIGNING_PASSWORD")}",
            'signing.secretKeyRingFile': "${getPropertyValue("SIGNING_SECRET_KEY_RING_FILE")}",
            'mavenCentralUsername'     : "${getPropertyValue("MAVEN_CENTRAL_TOKEN_USERNAME")}",
            'mavenCentralPassword'     : "${getPropertyValue("MAVEN_CENTRAL_TOKEN_PASSWORD")}",
            'sonatypeStagingProfileId' : "${getPropertyValue("SONATYPE_STAGING_PROFILE_ID")}"
    ]
}

tasks.register('publishDocs') {
    description = 'Publish AudioSwitch KDocs to gh-pages branch'
    group = 'Publishing'
    dependsOn 'audioswitch:dokkaHtml'
    dependsOn validateReleaseTag

    doLast {
        def releaseVersion = System.getenv("CIRCLE_TAG") ?: ""
        def githubToken = System.getenv("GITHUB_TOKEN")
        def repoSlug = "${System.env.CIRCLE_PROJECT_USERNAME}/${System.env.CIRCLE_PROJECT_REPONAME}"
        def gitRef = "https://${githubToken}@github.com/${repoSlug}.git"
        def remoteName = "upstream"

        // Add remote if it doesn't exist
        try {
            grgit.remote.add(name: remoteName, url: gitRef)
        } catch (Exception ignored) {
            // Remote already exists
        }

        // Fetch remote branches
        grgit.fetch(remote: remoteName)

        // Checkout gh-pages branch
        grgit.checkout(branch: 'gh-pages', startPoint: "remotes/${remoteName}/gh-pages", createBranch: true)

        // Create docs directory if it doesn't exist
        def docsDir = file("${rootDir}/docs")
        if (!docsDir.exists()) {
            docsDir.mkdirs()
        }

        // Copy documentation files
        copy {
            from "${rootDir}/audioswitch/build/dokka/html"
            into "${rootDir}/docs/${releaseVersion}"
        }

        // Create symlink for latest docs
        def latestLink = file("${rootDir}/docs/latest")
        if (latestLink.exists()) {
            latestLink.delete()
        }
        ant.symlink(link: "${rootDir}/docs/latest", resource: releaseVersion)

        // Add, commit and push changes
        grgit.add(patterns: ["docs/${releaseVersion}", "docs/latest"])
        grgit.commit(message: "${releaseVersion} release docs [skip ci]")
        grgit.push(remote: remoteName, refsOrSpecs: ['gh-pages'])

        // Return to release tag
        grgit.checkout(branch: releaseVersion)
    }
}
